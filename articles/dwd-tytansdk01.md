---
title: "TYTAN SDK で遊んでみる (1) — 入門の入門"
emoji: "🪐"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["poem", "Python", "qubo"]
published: false
---

# 目的

言い回しは適切ではないかもしれないが、QUBO (Quadratic Unconstrained Binary Optimization) という概念があって、これをソルバで最適化して組合せ最適化問題を解きたい、ということがある (らしい)。

今回、この QUBO の最適化を通じた組合せ最適化について、基本的なところを押さえておきたいという理由でつらつらと記事を書いてみようかと思って、初回の記事を書いてみることにした。

# はじめに

QUBO による組合せ最適化が何かということは後に回すとして、そういったことができるものに、[D-Wave Ocean SDK](https://docs.ocean.dwavesys.com/en/stable/) とか [PyQUBO](https://pyqubo.readthedocs.io/en/latest/) とかいうものがあるらしい。たぶんそれらと似たようなものに [TYTAN SDK](https://www.tytansdk.com/) というのがあって、今回これを使ってみたい。まったく詳しくないので、たまたま目にとまって、なおかつチュートリアルが用意されていて何となく良さそうというくらいの動機である。なお、D-Wave の実機を除いては、恐らく「擬似量子アニーリング」という手法になると思う。

やることはシンプルで、

1. 解きたい組み合わせ問題を QUBO 式という式で記述してやって、
2. ソルバに放り込めば、

記述が妥当であってなおかつ運が良ければ最適解や準最適解が得られるというものになる。

# ざっくりと

QUBO を使った組み合わせ問題の解放では、適当な変数を使って問題を解くのだが、かなり厳しい条件がある。

1. Binary (二値) というだけあって、変数 $q_0$, $q_1$, ... は 0 か 1 の 2 値しかとれない。
2. なおかつ、この変数について使える式の次数は Quadratic (二次) というだけあって、2 次式までである

つまり、$q_0^2$ は OK だが、$q_0^3$ や $q_0^4$ は NG である。線形結合の類は使えるので

- OK:
    - $H = q_0 + q_1^2$,
    - $H = (2 q_0 - q_1 + 3 q_2)^2 + 3 q_0 q_1$
- NG:
    - $H = q_0 + q_1^3$
    - $H = (2 q_0 - q_1 + 3 q_2)^3 + 3 q_0 q_1 q_2$

みたいな感じである。なお、$q_0 \in \{0, 1\}$ より $q_0^2 = q_0$ である。つまり、

$$
\begin{align*}
H = (q_0^2 + q_1^2) q_2
\end{align*}
$$

は見かけ上は 3 次式だが、整理すると $H = q_0 q_2 + q_1 q_2$ で 2 次式なので OK となる。

# 簡単な問題

この厳しい条件下で、「**足したら 2 になる数値を求めてみたい**」。つまり、解きたい問題は、$q_0, q_1 \in \{0, 1\}$ に対して

$$
\begin{align*}
q_0 + q_1 = 2
\tag{1}
\end{align*}
$$

というものを扱ってみたい。大変自明ではあるのだが、脳内では一瞬で

- $q_0=0, q_1=0$
- $q_0=0, q_1=1$
- $q_0=1, q_1=0$
- $q_0=1, q_1=1$

を試しているはずである。ということにする[^1]。

[^1]: 生物学は知らないのでよく分からない。

なんと、4 回も計算するのは面倒くさいので、やりたくない。PC にお任せしたいというのがこういった問題をソルバで解きたい動機であろう。

ところで、いわゆる “最適化問題” として解くので、何かしら**損失関数**的なもの —— つまり何かしらの実数値関数で、最小値をとるケースが最適解を与えるようなもの —— を用意してあげる必要がある。今回のケースであれば 2 つの損失関数 $H_1$ と $H_2$ が考えられそうである。

$$
\begin{align*}
H_1(q_0, q_1) = 2 - (q_0 + q_1)
\tag{2}
\end{align*}
$$

と

$$
\begin{align*}
H_2(q_0, q_1) = (q_0 + q_1 - 2)^2
\tag{3}
\end{align*}
$$

である。(2) 式は実は案に答えの当たりがついていないとこの形 (特に符号) にはできないので嫌な感じである。(3) 式は何も考えずに設計できて、頭を使わない。

## チュートリアルを ~~パクる~~ 参考にする

さて、TYTAN SDK のチュートリアルは [tytan_tutorial](https://github.com/tytansdk/tytan_tutorial) にあって、結構頻繁に更新されている。公式的にも `main` ブランチの最新のものを使ってくれという運用なので、そうしたい。但し、今回は安全を見て CI が通っている最新版とする:

## 問題を解く

```python
!pip install -q git+https://github.com/tytansdk/tytan.git@8d631cb
```

SDK の更新が早いので書き方も変わる。基本的に新しい簡便な書き方は新しいチュートリアルに載っている。ここでは [TYTAN tutorial おすすめ10（線形回帰）](https://colab.research.google.com/drive/1Zt9FFF48S0tYRgpoiTOaLxiaHpWjTgLg?usp=sharing) を参考にする。

必要なモジュールを import する。

```python
from tytan import symbols, Compile, sampler
```

さて、損失関数をそれぞれ定義してみよう:

```python
q0 = symbols('q0')
q1 = symbols('q1')

H1 = 2 - q0 - q1
H2 = (q0 + q1 - 2)**2
```

自明な形で損失関数が定義できたが、この段階まで到達することを「QUBO の定式化をする」と呼ぶらしい。

さて、これらを API に放り込めるようにするためにそれぞれコンパイルする:

```python
qubo1, offset1 = Compile(H1).get_qubo()
qubo2, offset2 = Compile(H2).get_qubo()
```

最適化の際に定数項は省いても問題がないので、`offset` 変数として省かれる。$H_1$ の式では定数項は 2 なので、`offset1 = 2` になっており、$H_2$ の式は展開すると定数項は 4 なので、`offset2 = 4` となる。よって、本質的には `qubo1 = -q0 -q1` と `qubo2 = -3*q0 -3*q1 + 2*q0*q1` が得られている。どこから `-3` が来たのか！？という感じであるが、$q_0^2 = q_0$ に注意すると `q0**2 - 4*q0 = q0 -4*q0 = -3*q0` として出てくるのである。

これで準備ができたので、深く考えずに問題を解く:

```python
solver = sampler.SASampler()

result = solver.run(qubo1)

for r in result[:2]:
    print(r)
```

> [{'q0': 1, 'q1': 1}, -2.0, 10]

よって、$q_0 = 1$ と $q_1 = 1$ が最適解を与えていることになる。「-2.0」はその時の $H_1$ の値であり、`qubo1 = -q0 -q1` であったので、-2 であることが分かる。「10」の部分はソースコードを見ると `unique_counts` というものらしいが今回は無視する。

$H_2$ についても解いてみよう:

```python
result = solver.run(qubo2)

for r in result[:2]:
    print(r)
```

> [{'q0': 1, 'q1': 1}, -4.0, 10]

同じく、$q_0 = 1$ と $q_1 = 1$ が最適解を与えていることが分かる。「-4.0」はその時の $H_2$ の値であり、`qubo2 = -3*q0 -3*q1 + 2*q0*q1` であったので、-4 であることが分かる。

# まとめ
